<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · BinBencherBackend.jl</title><meta name="title" content="Reference · BinBencherBackend.jl"/><meta property="og:title" content="Reference · BinBencherBackend.jl"/><meta property="twitter:title" content="Reference · BinBencherBackend.jl"/><meta name="description" content="Documentation for BinBencherBackend.jl."/><meta property="og:description" content="Documentation for BinBencherBackend.jl."/><meta property="twitter:description" content="Documentation for BinBencherBackend.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BinBencherBackend.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../walkthrough/">Walkthrough</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jakobnissen/BinBencherBackend.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/master/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.Bin" href="#BinBencherBackend.Bin"><code>BinBencherBackend.Bin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bin(name::AbstractString, ref::Reference, sequences)</code></pre><p><code>Bin</code>s each represent a bin created by the binner. Conceptually, they are simply a set of <code>Sequence</code> with a name attached. Practically, every <code>Bin</code> is benchmarked against all <code>Genome</code>s and <code>Clade</code>s of a given <code>Reference</code>, so each <code>Bin</code> stores data about its intersection with every genome/clade, e.g. its purity and recall.</p><p>Like <code>Source</code>s, <code>Bin</code>s also have an <em>assembly size</em> for a given <code>Genome</code>. This is the number of base pairs in the genomes covered by any sequence in the <code>Bin</code>, which is always a subset of the genome&#39;s assembly size.</p><p>Benchmark statistics for a <code>Bin</code>/<code>Genome</code> can be done with either <em>assemblies</em> or <em>genomes</em> as the ground truth.</p><ul><li>True positives (TP) are defined as the sum of assembly sizes over all sources in the genome</li><li>False positives (FP) are the sum of length of sequences in the bin not mapping to the genome</li><li>False negatives (FN) is either the genome assembly size or genome size minus TP.</li></ul><p>For <code>Bin</code>/<code>Clade</code> pairs B/C, recall is the maximal recall of B/Ch for all children Ch of C. Precision is the sum of lengths of sequences mapping to any child of the clade divided by the sum of lengths of all sequences in the bin.</p><p>See also: <a href="#BinBencherBackend.Binning"><code>Binning</code></a>, <a href="#BinBencherBackend.Genome"><code>Genome</code></a>, <a href="#BinBencherBackend.Clade"><code>Clade</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bin = first(binning.bins)
Bin &quot;C1&quot;
  Sequences: 2
  Breadth:   65
  Intersecting 1 genome

julia&gt; first(bin.sequences)
Sequence(&quot;s1&quot;, 25)

julia&gt; f1(first(ref.genomes), bin)
0.625</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/bin.jl#L1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.Binning" href="#BinBencherBackend.Binning"><code>BinBencherBackend.Binning</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Binning(::Union{IO, AbstractString}, ::Reference; kwargs...)</code></pre><p>A <code>Binning</code> represents a set of <code>Bin</code>s benchmarked against a <code>Reference</code>. <code>Binning</code>s can be created given a set of <code>Bin</code>s and a <code>Reference</code>, where the bins may potentially be loaded from a <code>.tsv</code> file. The fields <code>recovered_asms</code> and <code>recovered_genomes</code> are used for benchmarking, these are normally output using the <code>print_matrix</code> function.</p><p>A <code>Binning</code> is loaded from a tsv file, which is specified either as an <code>IO</code>, or its path as an <code>AbstractString</code>. If the path ends with <code>.gz</code>, automatically gzip decompress when reading the file.</p><p>See also: <a href="#BinBencherBackend.print_matrix-Tuple{Binning}"><code>print_matrix</code></a>, <a href="#BinBencherBackend.Bin"><code>Bin</code></a>, <a href="#Reference"><code>Reference</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bins = Binning(path_to_bins_file, ref);

julia&gt; bins isa Binning
true

julia&gt; BinBencherBackend.n_nc(binning)
0</code></pre><p><strong>Extended help</strong></p><p>Create with:</p><pre><code class="language-julia hljs">open(file) do io
    Binning(
        io::Union{IO, AbstractString},
        ref::Reference;
        min_size::Integer=1,
        min_seqs::Integer=1,
        binsplit_separator::Union{AbstractString, Char, Nothing}=nothing,
        disjoint::Bool=true,
        recalls=DEFAULT_RECALLS,
        precisions=DEFAULT_PRECISIONS,
        filter_genomes=Returns(true)
)</code></pre><ul><li><code>min_size</code>: Filter away bins with breadth lower than this</li><li><code>min_seqs</code>: Filter away bins with fewer sequences that this</li><li><code>binsplit_separator</code>: Split bins based on this separator (<code>nothing</code> means no binsplitting)</li><li><code>disjoint</code>: Throw an error if the same sequence is seen in multiple bins</li><li><code>recalls</code> and <code>precision</code>: The thresholds to benchmark with</li><li><code>filter_genomes</code>: A function <code>f(genome)::Bool</code>. Genomes for which it returns  <code>false</code> are ignored in benchmarking.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/binning.jl#L31-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.Clade" href="#BinBencherBackend.Clade"><code>BinBencherBackend.Clade</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Clade{Genome}(name::AbstractString, child::Union{Clade{Genome}, Genome})</code></pre><p>A <code>Clade</code> represents any clade above <code>Genome</code>. Every <code>Genome</code> is expected to belong to the same number of clades, e.g. there may be exactly 7 levels of clades above every <code>Genome</code>. <code>Clade</code>s always have at least one child (which is either a <code>Genome</code> or a <code>Clade</code> one rank lower), and a parent, unless it&#39;s the unique top clade from which all other clades and genomes descend from. The rank of a <code>Genome</code> is 0, clades that contain genomes have rank 1, and clades containing rank-1 clades have rank 2 etc. By default, zero-indexed ranks correspond to OTU, species, genus, family, order, class, phylum and domain.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; top_clade(ref)
Genus &quot;F&quot;, 3 genomes
├─ Species &quot;D&quot;, 2 genomes
│  ├─ Genome(gA)
│  └─ Genome(gB)
└─ Species &quot;E&quot;, 1 genome
   └─ Genome(gC)

julia&gt; top_clade(ref).children
2-element Vector{Clade{Genome}}:
 Species &quot;D&quot;, 2 genomes
 Species &quot;E&quot;, 1 genome</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/clade.jl#L3-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.FlagSet" href="#BinBencherBackend.FlagSet"><code>BinBencherBackend.FlagSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FlagSet &lt;: AbstractSet{Flag}</code></pre><p>Flags are compact sets of <code>Flag</code> associated to a Genome. You can construct them from an iterable of <code>Flag</code>, e.g. a 1-element tuple. <code>FlagSet</code> support most set operations efficiently.</p><p>See also: <a href="#BinBencherBackend.Flags.Flag"><code>Flag</code></a>, <a href="#BinBencherBackend.Genome"><code>Genome</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; flags = FlagSet((Flags.organism, Flags.virus));

julia&gt; Flags.virus in flags
true

julia&gt; isdisjoint(flags, FlagSet((Flags.organism,)))
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/flags.jl#L34-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.Flags.Flag" href="#BinBencherBackend.Flags.Flag"><code>BinBencherBackend.Flags.Flag</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Flag</code></pre><p>A flag is a boolean associated to a <code>Genome</code>, stored in a <code>Flags</code> object. A flag may be e.g. <code>Flag.organism</code>, signaling that the genome is known to be an organism.</p><p>See also: <a href="#BinBencherBackend.FlagSet"><code>FlagSet</code></a>, <a href="#BinBencherBackend.Genome"><code>Genome</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tryparse(Flag, &quot;organism&quot;) == Flags.organism
true

julia&gt; tryparse(Flag, &quot;Canada&quot;) === nothing
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/flags.jl#L14-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.Genome" href="#BinBencherBackend.Genome"><code>BinBencherBackend.Genome</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Genome(name::AbstractString [flags::FlagSet])</code></pre><p><code>Genome</code>s represent individual target genomes (organisms, plasmids, viruses etc), and are conceptually the lowest-level clade that can be reconstructed. <code>Genome</code>s contain one or more <code>Source</code>s, and belong to a single parent <code>Clade</code>. They are identified uniquely among genomes by their name.</p><p>A genome have a <em>genome size</em>, which is the sum of the length of all its sources. We consider this to be the true size of the biological genome (assuming its full sequence is contained in its sources), as well as an <em>assembly size</em>, which represent the sum of the assembly sizes of each source.</p><p>See also: <a href="#BinBencherBackend.Clade"><code>Clade</code></a>, <a href="#BinBencherBackend.Source"><code>Source</code></a>, <a href="#BinBencherBackend.mrca-Tuple{Union{Clade{Genome}, Genome}, Union{Clade{Genome}, Genome}}"><code>mrca</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gA, gB, gC = collect(ref.genomes);

julia&gt; flags(gA)
FlagSet with 1 element:
  BinBencherBackend.Flags.organism

julia&gt; mrca(gA, gB)
Species &quot;D&quot;, 2 genomes
├─ Genome(gA)
└─ Genome(gB)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/genome.jl#L15-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.Reference" href="#BinBencherBackend.Reference"><code>BinBencherBackend.Reference</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Reference(::Union{IO, AbstractString}; [min_seq_length=1])</code></pre><p>A <code>Reference</code> contains the ground truth to benchmark against. Conceptually, it consists of the following parts:</p><ul><li>A list of genomes, each with sources</li><li>The full taxonomic tree, as lists of clades</li><li>A list of sequences, each with a list of (source, span) to where it maps.</li></ul><p>Normally, the types <code>FlagSet</code> <code>Genome</code>, <code>Source</code>, <code>Clade</code> and <code>Sequence</code> do not need to be constructed manually, but are constructed when the <code>Reference</code> is loaded from a JSON file.</p><p>A <code>Reference</code> is loaded from a JSON file, which is specified either as an <code>IO</code>, or its path as an <code>AbstractString</code>. If the path ends with <code>.gz</code>, automatically gzip decompress when reading the file.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ref = Reference(path_to_ref_file; min_seq_length=3);

julia&gt; ref isa Reference
true

julia&gt; length(genomes(ref))
3

julia&gt; nseqs(ref)
11

julia&gt; first(ref.genomes) isa Genome
true</code></pre><p>See also: <a href="#BinBencherBackend.subset-Tuple{Reference}"><code>subset</code></a>, <a href="#BinBencherBackend.Genome"><code>Genome</code></a>, <a href="#BinBencherBackend.Clade"><code>Clade</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/reference.jl#L11-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.Sequence" href="#BinBencherBackend.Sequence"><code>BinBencherBackend.Sequence</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Sequence(name::AbstractString, length::Integer)</code></pre><p>Type that represents a binnable sequence. Sequences do not contain other information than their name and their length, and are identified by their name.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Sequence(&quot;abc&quot;, 5)
Sequence(&quot;abc&quot;, 5)

julia&gt; Sequence(&quot;abc&quot;, 5) == Sequence(&quot;abc&quot;, 9)
true

julia&gt; Sequence(&quot;abc&quot;, 0)
ERROR: ArgumentError: Cannot instantiate an empty sequence</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/sequence.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.Source" href="#BinBencherBackend.Source"><code>BinBencherBackend.Source</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Source{Genome}(g::Genome, name::AbstractString, length::Integer)</code></pre><p>Sources are the &quot;ground truth&quot; sequences that the binning attempts to recreate. For example, the assembled contigs of the reference genome (typically full, closed circular contigs) as found in NCBI or elsewhere are each <code>Source</code>s. Many <code>Genome</code>s only contain a single <code>Source</code> namely its full assembled genome. Each <code>Source</code> has a single parent <code>Genome</code>, and a unique name which identifies it.</p><p><code>Source</code>s have zero or more mapping <code>Sequence</code>s, that each map to the <code>Source</code> at a given span given by a 2-tuple <code>Tuple{Int, Int}</code>.</p><p><code>Source</code>s have an <em>assembly size</em>, which is the number of base pairs where any sequence map to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/source.jl#L22-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.assembly_size!-Tuple{Function, Vector{Tuple{Int64, Int64}}, Vector, Int64}" href="#BinBencherBackend.assembly_size!-Tuple{Function, Vector{Tuple{Int64, Int64}}, Vector, Int64}"><code>BinBencherBackend.assembly_size!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute -&gt; (breadth, total<em>bp), where breadth is the number of positions in <code>v</code> covered at least once, and total</em>bp the sum of the lengths of the sequences. <code>v</code> must be a <code>Vector</code> such that <code>all(by(i) isa Tuple{Integer, Integer} for i in v)</code>. The <code>scratch</code> input is mutated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/source.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.flags-Tuple{Genome}" href="#BinBencherBackend.flags-Tuple{Genome}"><code>BinBencherBackend.flags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flags(g::Genome)::FlagSet</code></pre><p>Returns the <code>Flag</code>s of the <code>Genome</code> as a <code>FlagSet</code>.</p><p>See also: <a href="#BinBencherBackend.Flags.Flag"><code>Flag</code></a>, <a href="#BinBencherBackend.FlagSet"><code>FlagSet</code></a></p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; flags(genome)
FlagSet with 1 element:
  BinBencherBackend.Flags.organism</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/genome.jl#L49-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.gold_standard-Tuple{Reference}" href="#BinBencherBackend.gold_standard-Tuple{Reference}"><code>BinBencherBackend.gold_standard</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gold_standard(
    ref::Reference
    [sequences, an iterable of bins or Binning];
    disjoint=true,
    recalls=DEFAULT_RECALLS,
    precisions=DEFAULT_PRECISIONS
)::Binning</code></pre><p>Create the optimal <code>Binning</code> object given a <code>Reference</code>, by the optimal binning of <code>sequences</code>. If <code>disjoint</code>, assign each sequence to only a single genome.</p><p>If <code>sequences</code> is not passed, use all sequences in <code>ref</code>. If a <code>Binning</code> is passed, use all sequences in any of its bins. Else, pass an iterable of <code>Sequence</code>. The elements of <code>Sequence</code> must be unique.</p><p><strong>Extended help</strong></p><p>Currently, the <code>disjoint</code> option uses a simple greedy algorithm to assign sequences to genomes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/binning.jl#L353-L373">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.intersecting-Tuple{Bin}" href="#BinBencherBackend.intersecting-Tuple{Bin}"><code>BinBencherBackend.intersecting</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersecting([Genome, Clade]=Genome, x::Bin)</code></pre><p>Get an iterator of the <code>Genome</code>s or <code>Clade</code>s that bin <code>x</code> intersects with. <code>intersecting(::Bin)</code> defaults to genomes.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; collect(intersecting(bin))
1-element Vector{Genome}:
 Genome(gA)

julia&gt; sort!(collect(intersecting(Clade, bin)); by=i -&gt; i.name)
2-element Vector{Clade{Genome}}:
 Species &quot;D&quot;, 2 genomes
 Genus &quot;F&quot;, 3 genomes</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/bin.jl#L177-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.is_organism-Tuple{Genome}" href="#BinBencherBackend.is_organism-Tuple{Genome}"><code>BinBencherBackend.is_organism</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_organism(g::Genome)::Bool</code></pre><p>Check if <code>g</code> is known to be an organism.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_organism(genome)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/genome.jl#L65-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.is_plasmid-Tuple{Genome}" href="#BinBencherBackend.is_plasmid-Tuple{Genome}"><code>BinBencherBackend.is_plasmid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_plasmid(g::Genome)::Bool</code></pre><p>Check if <code>g</code> is known to be a plasmid.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_plasmid(genome)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/genome.jl#L91-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.is_virus-Tuple{Genome}" href="#BinBencherBackend.is_virus-Tuple{Genome}"><code>BinBencherBackend.is_virus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_virus(g::Genome)::Bool</code></pre><p>Check if <code>g</code> is known to be a virus.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_virus(genome)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/genome.jl#L78-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.mrca-Tuple{Union{Clade{Genome}, Genome}, Union{Clade{Genome}, Genome}}" href="#BinBencherBackend.mrca-Tuple{Union{Clade{Genome}, Genome}, Union{Clade{Genome}, Genome}}"><code>BinBencherBackend.mrca</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mrca(a::Node, b::Node)::Node</code></pre><p>Compute the most recent common ancestor (MRCA) of <code>a</code> and <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/genome.jl#L193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.n_passing_bins" href="#BinBencherBackend.n_passing_bins"><code>BinBencherBackend.n_passing_bins</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">n_passing_bins(::Binning, recall, precision; level=0, assembly::Bool=false)::Integer</code></pre><p>Return the number of bins which correspond to any genome or clade at the given recall and precision levels. If <code>assembly</code> is set, a recall of 1.0 means a bin corresponds to a whole assembly, else it corresponds to a whole genome. The argument <code>level</code> sets the taxonomic rank: 0 for <code>Genome</code> (or assemblies).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; n_passing_bins(binning, 0.4, 0.71)
1

julia&gt; n_passing_bins(binning, 0.65, 0.71)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/binning.jl#L191-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.n_recovered-Tuple{Binning, Real, Real}" href="#BinBencherBackend.n_recovered-Tuple{Binning, Real, Real}"><code>BinBencherBackend.n_recovered</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">n_recovered(::Binning, recall, precision; level=0, assembly=false)::Integer</code></pre><p>Return the number of genomes or clades reconstructed in the <code>Binning</code> at the given recall and precision levels. If <code>assembly</code> is set, return the number of assemblies reconstructed instead. The argument <code>level</code> sets the taxonomic rank: 0 for <code>Genome</code> (or assemblies).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; n_recovered(binning, 0.4, 0.71)
1

julia&gt; n_recovered(binning, 0.4, 0.71; assembly=true)
2

julia&gt; n_recovered(binning, 0.4, 0.71; assembly=true, level=2)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/binning.jl#L160-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.passes_f1-Tuple{Bin, Real}" href="#BinBencherBackend.passes_f1-Tuple{Bin, Real}"><code>BinBencherBackend.passes_f1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">passes_f1(bin::Bin, threshold::Real; assembly::Bool=false)::Bool</code></pre><p>Computes if <code>bin</code> has an F1 score equal to, or higher than <code>threshold</code> for any genome.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; obs_f1 = f1(only(intersecting(bin)), bin)
0.625

julia&gt; passes_f1(bin, obs_f1)
true

julia&gt; passes_f1(bin, obs_f1 + 0.001)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/bin.jl#L311-L327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.passes_recall_precision-Tuple{Bin, Real, Real}" href="#BinBencherBackend.passes_recall_precision-Tuple{Bin, Real, Real}"><code>BinBencherBackend.passes_recall_precision</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">passes_recall_precision(bin::Bin, recall::Real, precision::Real; assembly::Bool=false)::Bool</code></pre><p>Computes if <code>bin</code> intersects with any <code>Genome</code> with at least the given recall and precision thresholds.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; (r, p) = recall_precision(only(intersecting(bin)), bin)
(recall = 0.45454545454545453, precision = 1.0)

julia&gt; passes_recall_precision(bin, 0.45, 1.0)
true

julia&gt; passes_recall_precision(bin, 0.46, 1.0)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/bin.jl#L334-L350">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.print_matrix-Tuple{Binning}" href="#BinBencherBackend.print_matrix-Tuple{Binning}"><code>BinBencherBackend.print_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_matrix(::Binning; level=0, assembly=true)</code></pre><p>Print the number of reconstructed assemblies or genomes at the given taxonomic level (rank). Level 0 corresponds to genomes, level 1 to species, etc. If <code>assembly</code>, print the number of reconstructed assemblies, else print the level of reconstructed genomes.</p><p>See also: <a href="#BinBencherBackend.Binning"><code>Binning</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/binning.jl#L249-L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.recall_precision-Tuple{Genome, Bin}" href="#BinBencherBackend.recall_precision-Tuple{Genome, Bin}"><code>BinBencherBackend.recall_precision</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">recall_precision(x::Union{Genome, Clade}, bin::Bin; assembly::Bool=true)</code></pre><p>Get the recall, precision as a 2-tuple of <code>Float64</code> for the given genome/bin pair. See the docstring for <code>Bin</code> for how this is computed.</p><p>See also: <a href="#BinBencherBackend.Bin"><code>Bin</code></a>, <a href="#BinBencherBackend.Binning"><code>Binning</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bingenome = only(intersecting(bin));

julia&gt; recall_precision(bingenome, bin)
(recall = 0.45454545454545453, precision = 1.0)

julia&gt; recall_precision(bingenome, bin; assembly=false)
(recall = 0.4, precision = 1.0)

julia&gt; recall_precision(bingenome.parent, bin; assembly=false)
(recall = 0.4, precision = 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/bin.jl#L229-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.recursively_delete_child!-Tuple{T} where T&lt;:Union{Clade{Genome}, Genome}" href="#BinBencherBackend.recursively_delete_child!-Tuple{T} where T&lt;:Union{Clade{Genome}, Genome}"><code>BinBencherBackend.recursively_delete_child!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Delete a child from the clade tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/genome.jl#L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.subset!-Tuple{Reference}" href="#BinBencherBackend.subset!-Tuple{Reference}"><code>BinBencherBackend.subset!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subset!(
        ref::Reference;
        sequences::Function=Returns(true),
        genomes::Function=Returns(true)
)::Reference</code></pre><p>Mutate <code>ref</code> in place, removing genomes and sequences. Keep only sequences S where <code>sequences(S)</code> returns <code>true</code> and genomes G for which <code>genomes(G)</code> returns <code>true</code>.</p><p>See also: <a href="#BinBencherBackend.subset-Tuple{Reference}"><code>subset</code></a>, <a href="#Reference"><code>Reference</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ref
Reference
  Genomes:    3
  Sequences:  11
  Ranks:      3
  Seq length: 10
  Assembled:  61.9 %

julia&gt; subset(ref; genomes=g -&gt; Flags.organism in flags(g))
Reference
  Genomes:    2
  Sequences:  11
  Ranks:      3
  Seq length: 10
  Assembled:  91.3 %

julia&gt; BinBencherBackend.subset(ref; sequences=s -&gt; length(s) ≥ 25)
Reference
  Genomes:    3
  Sequences:  9
  Ranks:      3
  Seq length: 25
  Assembled:  56.2 %</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/reference.jl#L108-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.subset-Tuple{Reference}" href="#BinBencherBackend.subset-Tuple{Reference}"><code>BinBencherBackend.subset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subset(ref::Reference; kwargs...)</code></pre><p>Non-mutating copying version of <code>subset!</code>. This is currently much slower than <code>subset!</code>.</p><p>See also: <a href="#BinBencherBackend.subset!-Tuple{Reference}"><code>subset!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/reference.jl#L211-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BinBencherBackend.update_matrix!-Tuple{Matrix{&lt;:Integer}, Vector{&lt;:AbstractFloat}, Vector{Float64}}" href="#BinBencherBackend.update_matrix!-Tuple{Matrix{&lt;:Integer}, Vector{&lt;:AbstractFloat}, Vector{Float64}}"><code>BinBencherBackend.update_matrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>For each precision column in the matrix, add one to the correct row given by the recall value at the given precision</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/BinBencherBackend.jl/blob/ae979fbcc59384bf7764f134ba88fc462c3ce71b/src/binning.jl#L621-L623">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../walkthrough/">« Walkthrough</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Wednesday 6 March 2024 08:50">Wednesday 6 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
