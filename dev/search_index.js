var documenterSearchIndex = {"docs":
[{"location":"input_files/#input_files","page":"Input files","title":"Input file formats","text":"","category":"section"},{"location":"input_files/#Binning-TSV-file","page":"Input files","title":"Binning TSV file","text":"","category":"section"},{"location":"input_files/","page":"Input files","title":"Input files","text":"The binning is a tab-separated values (TSV) file of the following format:","category":"page"},{"location":"input_files/","page":"Input files","title":"Input files","text":"The header must be exactly clustername\\tcontigname\nEvery subsequent line must be the clustername, then a tab, then the contigname.","category":"page"},{"location":"input_files/","page":"Input files","title":"Input files","text":"The format can be written as a regular expression:","category":"page"},{"location":"input_files/","page":"Input files","title":"Input files","text":"binning = \"clustername\\tcontigname\" (\"\\r?\\n\" bin)* (\"\\r?\\n\")?\nbin = identifier \"\\t\" identifier\nidentifier = \"[^\\t\\r\\n]*\"","category":"page"},{"location":"input_files/","page":"Input files","title":"Input files","text":"The file is assumed to be encoded in UTF-8. The identifiers may contain any arbitrary bytes except '\\t' (0x09), '\\n' (0x0a) or '\\r' (0x0d), including invalid unicode.","category":"page"},{"location":"input_files/#refjson","page":"Input files","title":"Reference JSON file","text":"","category":"section"},{"location":"input_files/","page":"Input files","title":"Input files","text":"This reference file is complex, as it contains a wealth of information about the genomes and their relationship. It is recommended to create this file using the CLI - see the relevant section of this documentation.","category":"page"},{"location":"input_files/","page":"Input files","title":"Input files","text":"If you want to create the JSON file yourself, you can learn its format by reading files in the BinBencherBackend.jl repository:","category":"page"},{"location":"input_files/","page":"Input files","title":"Input files","text":"A JSON Schema with descriptions at files/schema.json\nA small example reference in files/ref.json\nThe source code in src/reference.json - grep for ReferenceJSON","category":"page"},{"location":"benchmarking/#benchmarking","page":"Benchmarking","title":"Benchmarking a binning","text":"","category":"section"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"Benchmarking is done with by running binbench bench from command line. You will need the following two input files (see the section 'input files' for more info):","category":"page"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"A reference JSON file.\nYour bins in a two-column TSV file.","category":"page"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"Benchmarking is run with the following command:","category":"page"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"$ binbench bench out_dir reference.json binning.tsv","category":"page"},{"location":"benchmarking/#Command-line-arguments","page":"Benchmarking","title":"Command line arguments","text":"","category":"section"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"-s --sep: Set the binsplit separator to a string (by default, no separator is passed). When a separator is passed, every sequence is assumed to be named according to the format <samplename><separator><sequencename>, where:\n<samplename> uniquely identifies the sample of origin of the sequence\n<separator> is equal to the binsplit separator\nThe separator does not occur in the samplename\n<sequencename> is an identifier that uniquely identifies a sequence within a sample.\nBinBencher will then split every input bin by their sample as given by this format. All bin filters will be applied after this binsplitting procedure.\n--minsize: Remove bins where the sum of sequence lengths is smaller than this number\n--minseqs: Remove bins with fewer sequences than this number\n--keep-flags: See --remove_flags. Keep only genomes with all these flags set.\n--remove-flags: Every genome in the reference has a set of boolean attributes, e.g. virus, organism, plasmid etc. This argument takes a comma-separated list of flags, then removes every genome that matches the flag. E.g. --remove-flags organism,virus, all genomes that are flagged with either organism or virus is removed.\n--recalls: Comma-separated list of recall thresholds to use when computing the matrices of the binning\n--precisions: See --recalls\n--intersect: Allow sequences to be present in multiple bins. Without this flag, BinBencher will throw an error if any sequences is detected in multiple bins.","category":"page"},{"location":"benchmarking/#Output-files","page":"Benchmarking","title":"Output files","text":"","category":"section"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"log.txt: The log file. Look here for errors.\nstats.json: Some statistics on the overall binning, such as number of bins, number of sequences, and summary statistics of the bins.\nbins.json.gz: This file contains assembly recall, genomic recall and precision for every bin, with every genome and clade that intersects with the bin (i.e. have nonzero recall).\nrecovery.json: This JSON file contains the keys \"precisions\" and \"recalls\" with the precision/recall thresholds used when binning. It then contains the four arrays bins_genomic_recall, genomes_genomic_recall, bins_asm_recall and genomes_asm_recall. Each of these arrays contain N matrices, one per taxonomic rank of the reference, with the first matrix being the genomes and the last matrix the top taxonomic rank. Each matrix has one row per precision threshold and one column per recall threshold. It then gives the number of genomes/bins reconstructed at the given precision/recall thresholds. The bins_* matrices gives the number of bins passing the threshold, whereas the genomes_ gives the number of genomes for which at least 1 bin passes the threshold with that given genome. The *_genomic_* matrices counts genomic recall, whereas the *_asm_* matrices count asm recall.","category":"page"},{"location":"benchmarking/#Benchmarking-multiple-binnings-in-one-go","page":"Benchmarking","title":"Benchmarking multiple binnings in one go","text":"","category":"section"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"If you have several binnings, it's faster to benchmark them together, as the reference only needs to be loaded once. This can be done like so","category":"page"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"$ binbench bench out_dir reference.json bins1=binning_1.tsv bins2=binning_2.tsv","category":"page"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"Here, out_dir will be populated by the log file and one sub-directory per binning, here called bin1 and bins2. The sub-directories contain the same content as the output directory when running BinBencher with a single binning, except it does not contain the log file.","category":"page"},{"location":"nomenclariture/#Nomenclariture-of-BinBencher","page":"Nomenclariture","title":"Nomenclariture of BinBencher","text":"","category":"section"},{"location":"nomenclariture/#nomenclariture","page":"Nomenclariture","title":"Basic nomenclariture","text":"","category":"section"},{"location":"nomenclariture/","page":"Nomenclariture","title":"Nomenclariture","text":"A sequence is the sequences that are to be clustered by the binner. I also sometimes call this a contig, because in most applications, binners are used to bin contigs.\nA genome is a target genome that should be reconstructed by the binner. It can be a virus, organism, plasmid or any other genetic entity. Every genome have one or more sources, zero or more flags, and one parent clade.\nA flag marks the certaincy about a boolean attribute of a genome, like \"is this a virus?\".\nA source are the DNA sequences that genomes are composed of. E.g. for a bacteria, its sources are all its chromosomes. For plasmids, its only source is its full-length sequence.  Sources are typically the full genome reference sequences from e.g. NCBI's RefSeq. Sequences map to zero or more sources at particular spans, i.e. a contiguous range from a starting to a stopping position.\nA clade contain one or more genomes, or clades, known as its children. Clades containing genomes are rank 1, and clades containing rank N clades are rank N+1 clades. By extension, genomes have rank 0. A clade never has children of mixed ranks. All genomes descend from a chain of exactly N ranks of clades, where N > 0.\nA bin is a set of sequences created by the binner. Every bin is benchmarked against all genomes and clades in the reference.\nA reference is composed of:\nThe set of genomes to benchmark against, which all ultimately descend from a single common clade.\nIts set of sequences each with zero or more mappings to its genomes' sources.\nA binning is a set of bins benchmarked against a reference, where every bin is a subset of the reference's sequences.","category":"page"},{"location":"nomenclariture/","page":"Nomenclariture","title":"Nomenclariture","text":"In the equations below, we denote genomes G. Genomes can be considered disjoint sets of mapping positions (i.e. genomic positions), where each position is a basepair in a source of the genome. The total set of positions in the reference is Y = cup_G. Let X be the set of sequences S to be binned. Each sequence has a length L_S and can be considered as a set of mapping positions S subseteq Y. Note that the cardinality of this set S need not be equal to the sequence's length L_S.","category":"page"},{"location":"nomenclariture/","page":"Nomenclariture","title":"Nomenclariture","text":"If we have a set of sequences x subseteq X and a set of mapping positions y subseteq Y, let us define x doublecap y = S in x  S cap y neq emptyset , i.e. the set of sequences in x that have mapping positions in y.","category":"page"},{"location":"nomenclariture/","page":"Nomenclariture","title":"Nomenclariture","text":"A genome's assembly A_G = G cap cup_X are all mapping positions in the genome covered by any sequence in the dataset.","category":"page"},{"location":"nomenclariture/","page":"Nomenclariture","title":"Nomenclariture","text":"A bin B is a set of sequences B subseteq X. For any bin-genome pair BG, we define:","category":"page"},{"location":"nomenclariture/","page":"Nomenclariture","title":"Nomenclariture","text":"The true positives TP_BG = cup_S in B S cap G, the number of mapping positions in G that any sequence of B maps to.\nThe false positives FP_BG = sum_S in G setminus (B doublecap G) L_S is the sum of lengths of sequences in B that does not map to any position in G.\nThe false genomic negatives FG_BG = G - TP_BG is all positions in G not covered by any sequence in B.\nThe false assembly negatives FA_BG = A_G - TP_BG is the assembly of G not covered by any sequence in B.","category":"page"},{"location":"nomenclariture/#Derived-metrics","page":"Nomenclariture","title":"Derived metrics","text":"","category":"section"},{"location":"nomenclariture/","page":"Nomenclariture","title":"Nomenclariture","text":"BinBencher computes a bunch of different metrics. The most central ones are given here. More may be added in the future.","category":"page"},{"location":"nomenclariture/","page":"Nomenclariture","title":"Nomenclariture","text":"The precision of a bin-genome pair is fracTP_BGTP_BG + FP_BG\nThe genomic recall is fracTP_BGTP_BG + FG_BG\nThe assembly recall is fracTP_BGTP_BG + FA_BG","category":"page"},{"location":"nomenclariture/","page":"Nomenclariture","title":"Nomenclariture","text":"Note that","category":"page"},{"location":"nomenclariture/","page":"Nomenclariture","title":"Nomenclariture","text":"These metrics are only defined for bin-genome pairs. It is not sensical to talk about the precision of a genome without specifying with respect to which bin.\nThe assembly recall is never lower than the genomic recall.","category":"page"},{"location":"nomenclariture/","page":"Nomenclariture","title":"Nomenclariture","text":"The most useful measures are the number of recovered bins or genomes at a given recall/precision threshold. This counts the total number of genomes (bins, respectively) which, when paired with any bin (genomes, resp.) has a recall and precision over the threhold. Both these measures can be computed for assembly or genomic recall.","category":"page"},{"location":"backend_overview/#BinBencherBackend.jl","page":"Overview","title":"BinBencherBackend.jl","text":"","category":"section"},{"location":"backend_overview/","page":"Overview","title":"Overview","text":"This is an ordinary Julia package that the CLI tool BinBencher.jl calls into for its analysis. The backend is useful for users who want to do more complex analysis not provided by the CLI wrapper.","category":"page"},{"location":"backend_overview/#Installation","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"backend_overview/","page":"Overview","title":"Overview","text":"Install Julia - preferably using juliaup: https://github.com/JuliaLang/juliaup\nLaunch Julia: julia\nPress ] to enter package mode. You can exit package mode with backspace.\nIn package mode, type add BinBencherBackend to download and install the benchmarking software","category":"page"},{"location":"backend_overview/#Quickstart","page":"Overview","title":"Quickstart","text":"","category":"section"},{"location":"backend_overview/","page":"Overview","title":"Overview","text":"using BinBencherBackend\nref =  Reference(\"files/ref.json\")\nbins = Binning(\"files/clusters.tsv\", ref)\nprint_matrix(bins)","category":"page"},{"location":"reference/#Reference","page":"API Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [BinBencherBackend]\nOrder   = [:type, :function]","category":"page"},{"location":"reference/#BinBencherBackend.Bin","page":"API Reference","title":"BinBencherBackend.Bin","text":"Bin(\n    name::AbstractString,\n    ref::Reference,\n    sequences,\n    considered_genomes::Union{Set{Genome}, Nothing}=nothing\n)\n\nConstruct a bin from an iterable of Sequence from a Reference.\n\nIf considered_genomes is not nothing, then any genomes not in the set will be ignored and so sequences mapping to those genomes will not count as contamination, and nor will the bin contain information about sequences mapping to those genomes.\n\nExamples\n\njulia> bin = first(binning.bins)\nBin \"C1\"\n  Sequences: 2\n  Breadth:   65\n  Intersecting 1 genome\n\njulia> first(bin.sequences)\nSequence(\"s1\", 25)\n\njulia> f1(first(ref.genomes), bin)\n0.5714285714285715\n\nSee also: Binning, Genome, Clade\n\nExtended help\n\nBins each represent a bin created by the binner. Conceptually, they are simply a set of Sequence with a name attached. Practically, every Bin is benchmarked against all Genomes and Clades of a given Reference, so each Bin stores data about its intersection with every genome/clade, e.g. its purity and recall.\n\nLike Sources, Bins also have an assembly size for a given Genome. This is the number of base pairs in the genomes covered by any sequence in the Bin, which is always a subset of the genome's assembly size.\n\nBenchmark statistics for a Bin/Genome can be done with either assemblies or genomes as the ground truth.\n\nTrue positives (TP) are defined as the sum of assembly sizes over all sources in the genome\nFalse positives (FP) are the sum of length of sequences in the bin not mapping to the genome\nFalse negatives (FN) is either the genome assembly size or genome size minus TP.\n\nFor Bin/Clade pairs B/C, recall is the maximal recall of B/Ch for all children Ch of C. Precision is the sum of lengths of sequences mapping to any child of the clade divided by the sum of lengths of all sequences in the bin.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinBencherBackend.Binning","page":"API Reference","title":"BinBencherBackend.Binning","text":"Binning(::Union{IO, AbstractString}, ::Reference; kwargs...)\n\nA Binning represents a set of Bins benchmarked against a Reference. Binnings can be created given a set of Bins and a Reference, where the bins may potentially be loaded from a .tsv file. The fields recovered_asms and recovered_genomes are used for benchmarking, these are normally output using the print_matrix function.\n\nA Binning is loaded from a tsv file, which is specified either as an IO, or its path as an AbstractString. If the path ends with .gz, automatically gzip decompress when reading the file.\n\nSee also: print_matrix, Bin, Reference\n\nExamples\n\njulia> bins = Binning(path_to_bins_file, ref);\n\n\njulia> bins isa Binning\ntrue\n\njulia> BinBencherBackend.n_nc(binning)\n0\n\nExtended help\n\nCreate with:\n\nopen(file) do io\n    Binning(\n        io::Union{IO, AbstractString},\n        ref::Reference;\n        min_size::Integer=1,\n        min_seqs::Integer=1,\n        binsplit_separator::Union{AbstractString, Char, Nothing}=nothing,\n        disjoint::Bool=true,\n        recalls=DEFAULT_RECALLS,\n        precisions=DEFAULT_PRECISIONS,\n        filter_genomes=Returns(true),\n        filter_bins=Returns(true),\n)\n\nmin_size: Filter away bins with breadth lower than this\nmin_seqs: Filter away bins with fewer sequences that this\nbinsplit_separator: Split bins based on this separator (nothing means no binsplitting)\ndisjoint: Throw an error if the same sequence is seen in multiple bins\nrecalls and precision: The thresholds to benchmark with\nfilter_genomes: A function f(genome)::Bool. Genomes for which it returns  false are ignored in benchmarking.\nfilter_bins: A function f(bin)::Bool. Bins for which it returns false are  removed from the Binning. This filter is applies after min_size and min_seqs  filter.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinBencherBackend.Binning-Tuple{Vector{Bin}, Reference}","page":"API Reference","title":"BinBencherBackend.Binning","text":"Binning(bins::Vector{Bin}, ref::Reference; kwargs...)\n\nCreate a Binning from a vector of Bin. The allowed keyword arguments are: recalls, precisions, disjoint, see the main docstring for Binning for their meaning.\n\njulia> binning = Binning([bin], ref);\n\njulia> n_bins(binning)\n1\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinBencherBackend.Clade","page":"API Reference","title":"BinBencherBackend.Clade","text":"Clade{Genome}(name::AbstractString, child::Union{Clade{Genome}, Genome})\n\nA Clade represents any clade above Genome. Every Genome is expected to belong to the same number of clades, e.g. there may be exactly 7 levels of clades above every Genome. Clades always have at least one child (which is either a Genome or a Clade one rank lower), and a parent, unless it's the unique top clade from which all other clades and genomes descend from. The rank of a Genome is 0, clades that contain genomes have rank 1, and clades containing rank-1 clades have rank 2 etc. By default, zero-indexed ranks correspond to OTU, species, genus, family, order, class, phylum and domain.\n\nExamples\n\njulia> top_clade(ref)\nGenus \"F\", 3 genomes\n├─ Species \"D\", 2 genomes\n│  ├─ Genome(gA)\n│  └─ Genome(gB)\n└─ Species \"E\", 1 genome\n   └─ Genome(gC)\n\njulia> top_clade(ref).children\n2-element Vector{Clade{Genome}}:\n Species \"D\", 2 genomes\n Species \"E\", 1 genome\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinBencherBackend.FlagSet","page":"API Reference","title":"BinBencherBackend.FlagSet","text":"FlagSet <: AbstractSet{Flag}\n\nFlags are compact sets of Flag associated to a Genome. You can construct them from an iterable of Flag, e.g. a 1-element tuple. FlagSet support most set operations efficiently.\n\nSee also: Flag, Genome\n\nExamples\n\njulia> flags = FlagSet((Flags.organism, Flags.virus));\n\n\njulia> Flags.virus in flags\ntrue\n\njulia> isdisjoint(flags, FlagSet((Flags.organism,)))\nfalse\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinBencherBackend.Flags.Flag","page":"API Reference","title":"BinBencherBackend.Flags.Flag","text":"Flag\n\nA flag is a boolean associated to a Genome, stored in a Flags object. A flag may be e.g. Flag.organism, signaling that the genome is known to be an organism.\n\nSee also: FlagSet, Genome\n\nExamples\n\njulia> tryparse(Flag, \"organism\") == Flags.organism\ntrue\n\njulia> tryparse(Flag, \"Canada\") === nothing\ntrue\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinBencherBackend.Genome","page":"API Reference","title":"BinBencherBackend.Genome","text":"Genome(name::AbstractString [flags::FlagSet])\n\nGenomes represent individual target genomes (organisms, plasmids, viruses etc), and are conceptually the lowest-level clade that can be reconstructed. Genomes contain one or more Sources, and belong to a single parent Clade. They are identified uniquely among genomes by their name.\n\nA genome have a genome size, which is the sum of the length of all its sources. We consider this to be the true size of the biological genome (assuming its full sequence is contained in its sources), as well as an assembly size, which represent the sum of the assembly sizes of each source.\n\nSee also: Clade, Source, mrca\n\nExamples\n\njulia> gA, gB, gC = collect(ref.genomes);\n\n\njulia> flags(gA)\nFlagSet with 1 element:\n  BinBencherBackend.Flags.organism\n\njulia> mrca(gA, gB)\nSpecies \"D\", 2 genomes\n├─ Genome(gA)\n└─ Genome(gB)\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinBencherBackend.Reference","page":"API Reference","title":"BinBencherBackend.Reference","text":"Reference(::Union{IO, AbstractString})\n\nA Reference contains the ground truth to benchmark against. Conceptually, it consists of the following parts:\n\nA list of genomes, each with sources\nThe full taxonomic tree, as lists of clades\nA list of sequences, each with a list of (source, span) to where it maps.\n\nNormally, the types FlagSet Genome, Source, Clade and Sequence do not need to be constructed manually, but are constructed when the Reference is loaded from a JSON file.\n\nA Reference is loaded from a JSON file, which is specified either as an IO, or its path as an AbstractString. If the path ends with .gz, automatically gzip decompress when reading the file.\n\nExamples\n\njulia> ref = Reference(path_to_ref_file);\n\n\njulia> ref isa Reference\ntrue\n\njulia> length(genomes(ref))\n3\n\njulia> n_seqs(ref)\n11\n\njulia> first(ref.genomes) isa Genome\ntrue\n\nSee also: subset, Genome, Clade\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinBencherBackend.Sequence","page":"API Reference","title":"BinBencherBackend.Sequence","text":"Sequence(name::AbstractString, length::Integer)\n\nType that represents a binnable sequence. Sequences do not contain other information than their name and their length, and are identified by their name.\n\nExamples\n\n```jldoctest julia> Sequence(\"abc\", 5) Sequence(\"abc\", 5)\n\njulia> Sequence(\"abc\", 5) == Sequence(\"abc\", 9) true\n\njulia> Sequence(\"abc\", 0) ERROR: ArgumentError: Cannot instantiate an empty sequence [...]\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinBencherBackend.Source","page":"API Reference","title":"BinBencherBackend.Source","text":"Source{Genome}(g::Genome, name::AbstractString, length::Integer)\n\nSources are the \"ground truth\" sequences that the binning attempts to recreate. For example, the assembled contigs of the reference genome (typically full, closed circular contigs) as found in NCBI or elsewhere are each Sources. Many Genomes only contain a single Source namely its full assembled genome. Each Source has a single parent Genome, and a unique name which identifies it.\n\nSources have zero or more mapping Sequences, that each map to the Source at a given span given by a 2-tuple Tuple{Int, Int}.\n\nSources have an assembly size, which is the number of base pairs where any sequence map to.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinBencherBackend.assembly_size!-Tuple{Function, Vector{Tuple{Int64, Int64}}, Vector, Int64}","page":"API Reference","title":"BinBencherBackend.assembly_size!","text":"Compute -> (breadth, totalbp), where breadth is the number of positions in v covered at least once, and totalbp the sum of the lengths of the sequences. v must be a Vector such that all(by(i) isa Tuple{Integer, Integer} for i in v). The scratch input is mutated.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinBencherBackend.flags-Tuple{Genome}","page":"API Reference","title":"BinBencherBackend.flags","text":"flags(g::Genome)::FlagSet\n\nReturns the Flags of the Genome as a FlagSet.\n\nSee also: Flag, FlagSet\n\nExample\n\njulia> flags(genome)\nFlagSet with 1 element:\n  BinBencherBackend.Flags.organism\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinBencherBackend.gold_standard-Tuple{Reference}","page":"API Reference","title":"BinBencherBackend.gold_standard","text":"gold_standard(\n    ref::Reference\n    [sequences, a Binning or an iterable of Sequence];\n    disjoint=true,\n    recalls=DEFAULT_RECALLS,\n    precisions=DEFAULT_PRECISIONS\n)::Binning\n\nCreate the optimal Binning object given a Reference, by the optimal binning of the Sequences in sequences. If disjoint, assign each sequence to only a single genome.\n\nIf sequences is not passed, use all sequences in ref. If a Binning is passed, use all sequences in any of its bins. Else, pass an iterable of Sequence.\n\nExtended help\n\nCurrently, the disjoint option uses a simple greedy algorithm to assign sequences to genomes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinBencherBackend.intersecting-Tuple{Bin}","page":"API Reference","title":"BinBencherBackend.intersecting","text":"intersecting([Genome, Clade]=Genome, x::Bin)\n\nGet an iterator of the Genomes or Clades that bin x intersects with. intersecting(::Bin) defaults to genomes.\n\nExample\n\njulia> collect(intersecting(bin))\n1-element Vector{Genome}:\n Genome(gA)\n\njulia> sort!(collect(intersecting(Clade, bin)); by=i -> i.name)\n2-element Vector{Clade{Genome}}:\n Species \"D\", 2 genomes\n Genus \"F\", 3 genomes\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinBencherBackend.is_organism-Tuple{Genome}","page":"API Reference","title":"BinBencherBackend.is_organism","text":"is_organism(g::Genome)::Bool\n\nCheck if g is known to be an organism.\n\nExample\n\njulia> is_organism(genome)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinBencherBackend.is_plasmid-Tuple{Genome}","page":"API Reference","title":"BinBencherBackend.is_plasmid","text":"is_plasmid(g::Genome)::Bool\n\nCheck if g is known to be a plasmid.\n\nExample\n\njulia> is_plasmid(genome)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinBencherBackend.is_virus-Tuple{Genome}","page":"API Reference","title":"BinBencherBackend.is_virus","text":"is_virus(g::Genome)::Bool\n\nCheck if g is known to be a virus.\n\nExample\n\njulia> is_virus(genome)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinBencherBackend.mrca-Tuple{Union{Clade{Genome}, Genome}, Union{Clade{Genome}, Genome}}","page":"API Reference","title":"BinBencherBackend.mrca","text":"mrca(a::Node, b::Node)::Node\n\nCompute the most recent common ancestor (MRCA) of a and b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinBencherBackend.n_passing_bins-Tuple{Binning, Real, Real}","page":"API Reference","title":"BinBencherBackend.n_passing_bins","text":"n_passing_bins(::Binning, recall, precision; level=0, assembly::Bool=false)::Integer\n\nReturn the number of bins which correspond to any genome or clade at the given recall and precision levels. If assembly is set, a recall of 1.0 means a bin corresponds to a whole assembly, else it corresponds to a whole genome. The argument level sets the taxonomic rank: 0 for Genome (or assemblies).\n\nExamples\n\njulia> n_passing_bins(binning, 0.4, 0.71)\n1\n\njulia> n_passing_bins(binning, 0.65, 0.71)\n0\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinBencherBackend.n_recovered-Tuple{Binning, Real, Real}","page":"API Reference","title":"BinBencherBackend.n_recovered","text":"n_recovered(::Binning, recall, precision; level=0, assembly=false)::Integer\n\nReturn the number of genomes or clades reconstructed in the Binning at the given recall and precision levels. If assembly is set, return the number of assemblies reconstructed instead. The argument level sets the taxonomic rank: 0 for Genome (or assemblies).\n\nExamples\n\njulia> n_recovered(binning, 0.4, 0.71)\n1\n\njulia> n_recovered(binning, 0.4, 0.71; assembly=true)\n2\n\njulia> n_recovered(binning, 0.4, 0.71; assembly=true, level=2)\n1\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinBencherBackend.passes_f1-Tuple{Bin, Real}","page":"API Reference","title":"BinBencherBackend.passes_f1","text":"passes_f1(bin::Bin, threshold::Real; assembly::Bool=false)::Bool\n\nComputes if bin has an F1 score equal to, or higher than threshold for any genome.\n\nExamples\n\njulia> obs_f1 = f1(only(intersecting(bin)), bin)\n0.5714285714285715\n\njulia> passes_f1(bin, obs_f1)\ntrue\n\njulia> passes_f1(bin, obs_f1 + 0.001)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinBencherBackend.passes_recall_precision-Tuple{Bin, Real, Real}","page":"API Reference","title":"BinBencherBackend.passes_recall_precision","text":"passes_recall_precision(bin::Bin, recall::Real, precision::Real; assembly::Bool=false)::Bool\n\nComputes if bin intersects with any Genome with at least the given recall and precision thresholds.\n\nExamples\n\njulia> (r, p) = recall_precision(only(intersecting(bin)), bin)\n(recall = 0.4, precision = 1.0)\n\njulia> passes_recall_precision(bin, 0.40, 1.0)\ntrue\n\njulia> passes_recall_precision(bin, 0.41, 1.0)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinBencherBackend.print_matrix-Tuple{Binning}","page":"API Reference","title":"BinBencherBackend.print_matrix","text":"print_matrix(::Binning; level=0, assembly=false)\n\nPrint the number of reconstructed assemblies or genomes at the given taxonomic level (rank). Level 0 corresponds to genomes, level 1 to species, etc. If assembly, print the number of reconstructed assemblies, else print the level of reconstructed genomes.\n\nSee also: Binning\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinBencherBackend.recall_precision-Tuple{Genome, Bin}","page":"API Reference","title":"BinBencherBackend.recall_precision","text":"recall_precision(x::Union{Genome, Clade}, bin::Bin; assembly::Bool=true)\n\nGet the recall, precision NamedTuple of Float64 for the given genome/bin pair. See the docstring for Bin for how this is computed.\n\nSee also: Bin, Binning\n\nExamples\n\njulia> bingenome = only(intersecting(bin));\n\n\njulia> recall_precision(bingenome, bin)\n(recall = 0.4, precision = 1.0)\n\njulia> recall_precision(bingenome, bin; assembly=false)\n(recall = 0.4, precision = 1.0)\n\njulia> recall_precision(bingenome.parent, bin; assembly=false)\n(recall = 0.4, precision = 1.0)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinBencherBackend.recursively_delete_child!-Tuple{T} where T<:Union{Clade{Genome}, Genome}","page":"API Reference","title":"BinBencherBackend.recursively_delete_child!","text":"Delete a child from the clade tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinBencherBackend.subset!-Tuple{Reference}","page":"API Reference","title":"BinBencherBackend.subset!","text":"subset!(\n        ref::Reference;\n        sequences::Function=Returns(true),\n        genomes::Function=Returns(true)\n)::Reference\n\nMutate ref in place, removing genomes and sequences. Keep only sequences S where sequences(S) returns true and genomes G for which genomes(G) returns true.\n\nSee also: subset, Reference\n\nExamples\n\njulia> ref\nReference\n  Genomes:    3\n  Sequences:  11\n  Ranks:      3\n  Seq length: 10\n  Assembled:  61.9 %\n\njulia> subset(ref; genomes=g -> Flags.organism in flags(g))\nReference\n  Genomes:    2\n  Sequences:  11\n  Ranks:      3\n  Seq length: 10\n  Assembled:  91.3 %\n\njulia> BinBencherBackend.subset(ref; sequences=s -> length(s) ≥ 25)\nReference\n  Genomes:    3\n  Sequences:  9\n  Ranks:      3\n  Seq length: 25\n  Assembled:  56.2 %\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinBencherBackend.subset-Tuple{Reference}","page":"API Reference","title":"BinBencherBackend.subset","text":"subset(ref::Reference; kwargs...)\n\nNon-mutating copying version of subset!. This is currently much slower than subset!.\n\nSee also: subset!\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinBencherBackend.update_matrix!-Tuple{Matrix{<:Integer}, Vector{<:AbstractFloat}, Vector{Float64}}","page":"API Reference","title":"BinBencherBackend.update_matrix!","text":"For each precision column in the matrix, add one to the correct row given by the recall value at the given precision\n\n\n\n\n\n","category":"method"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"DocTestSetup = quote\n    using BinBencherBackend\n\n    (path_to_ref_file, path_to_bins_file) = let\n        dir = joinpath(Base.pkgdir(BinBencherBackend), \"files\")\n        (joinpath(dir, \"ref.json\"), joinpath(dir, \"clusters.tsv\"))\n    end\nend","category":"page"},{"location":"walkthrough/#BinBencherBackend.jl-walkthrough","page":"Walkthrough","title":"BinBencherBackend.jl walkthrough","text":"","category":"section"},{"location":"walkthrough/#Loading-the-reference","page":"Walkthrough","title":"Loading the reference","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"First, let's load the reference:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> using BinBencherBackend\n\njulia> ref = Reference(path_to_ref_file)\nReference\n  Genomes:    3\n  Sequences:  11\n  Ranks:      3\n  Seq length: 10\n  Assembled:  61.9 %","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"This gives us a few statistics about the reference:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Number of genomes\nNumber of sequences\nNumber of taxonomic ranks (strain, species, genus...)\nLength of shortest sequence\nTotal length of genomes that are assembled","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"The genomes here contain both plasmids and organisms. Let's filter the reference using subset! to only retain organisms, and sequences of length 10 or more:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> subset!(ref;\n           genomes = is_organism,\n           sequences = s -> length(s) >= 10\n       )\nReference\n  Genomes:    2\n  Sequences:  11\n  Ranks:      3\n  Seq length: 10\n  Assembled:  91.3 %","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"note: Note\nThe function subset! will mutate the reference, whereas the function subset will create a new independent reference. At the moment, the latter is much slower.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"We removed a single genome, namely one labeled as virus.","category":"page"},{"location":"walkthrough/#Genomes","page":"Walkthrough","title":"Genomes","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"We can explore the genomes contained in the reference with the genomes function, which returns an iterable of Genome (in this case, a Set):","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> genomes(ref)\nSet{Genome} with 2 elements:\n  Genome(gA)\n  Genome(gB)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Let's look at a Genome in more detail:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> genome, genome2 = genomes(ref);\n\njulia> genome\nGenome \"gA\"\n  Parent:        \"D\"\n  Genome size:   100\n  Assembly size: 88 (88.0 %)\n  Sources:       1\n  Flags:         1 (organism)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"The flags can be extracted with the flags(genome) function - each genome contains zero or more flags:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> flags(genome)\nFlagSet with 1 element:\n  BinBencherBackend.Flags.organism","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"... in this case, this genome is an organism as opposed to a plasmid or virus. You can see all possible flags with instances(Flags.Flag).","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"See also the helper functions is_organism, is_virus and is_plasmid","category":"page"},{"location":"walkthrough/#Sources","page":"Walkthrough","title":"Sources","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"The genome has one source - let's look at that","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> source = only(genome.sources)\nSource \"subjA1\"\ngenome:          Genome(gA)\n  Length:        100\n  Assembly size: 88\n  Sequences:     6","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"A Source is one of the genomic sequences that genomes are composed of. This is distinct from the assembled sequences that we will be binning - a Source represents the reference sequence, typically the full genome, assembled from a sequencing run on a clonal colony. For this genome, we can see it has a length of 100 bp, and that 5 sequences map to this source, covering 88 bp.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"We can get the sequences mapping to this source:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> source.sequences\n6-element Vector{Tuple{Sequence, Tuple{Int64, Int64}}}:\n (Sequence(\"s1\", 25), (5, 29))\n (Sequence(\"s1\", 25), (10, 34))\n (Sequence(\"s2\", 40), (1, 40))\n (Sequence(\"s3\", 50), (51, 98))\n (Sequence(\"s7\", 20), (21, 40))\n (Sequence(\"s8\", 25), (2, 26))","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Where, e.g. the first entrance tells us that the sequence \"s2\" with a length of 40 maps to positions 1:40 (both inclusive).","category":"page"},{"location":"walkthrough/#Clades","page":"Walkthrough","title":"Clades","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Genomes are organised into a taxonomic hierarchy. We can find the immediate parent of a genome by accessing the field genome.parent. Let's look at another genome:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> genome2\nGenome \"gB\"\n  Parent:        \"D\"\n  Genome size:   50\n  Assembly size: 49 (98.0 %)\n  Sources:       2\n  Flags:         1 (organism)\n\njulia> clade = genome2.parent\nSpecies \"D\", 2 genomes\n├─ Genome(gA)\n└─ Genome(gB)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"The parent is an instance of a Clade. Clades are at a specific rank: Rank 1 for species, 2 for genus, 3 for family, etc. Every clade has one or more children: These are the clades one rank lower. Conceptually, rank zero corresponds to Genomes (OTUs, for this reference dataset)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> clade.children\n2-element Vector{Genome}:\n Genome(gA)\n Genome(gB)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"We can find the most recent common ancestor (MRCA) of genome and genome2 like this:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> mrca(genome, genome2)\nSpecies \"D\", 2 genomes\n├─ Genome(gA)\n└─ Genome(gB)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"They are very distantly related, so the domain \"Bacteria\", one of the highest ranked Clades, are their most recent common ancestor.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"The top clade can be found with the top_clade(ref) function, which is the universal ancestor of all clades in the reference.","category":"page"},{"location":"walkthrough/#Binnings","page":"Walkthrough","title":"Binnings","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"A Binning is a set of bins benchmarked against a reference. We can load a set of Vamb bins and turn it into a Binning object like this:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> binning = Binning(path_to_bins_file, ref)\nBinning\n  Reference\n    Genomes:    2\n    Sequences:  11\n    Ranks:      3\n    Seq length: 10\n    Assembled:  91.3 %\n  Bins:        6\n  NC genomes:  0\n  HQ bins:     0\n  Mean bin genome   R/P/F1: 0.51 / 1.0 / 0.672\n  Mean bin assembly R/P/F1: 0.546 / 1.0 / 0.704\n  Precisions: [0.6, 0.7, 0.8, 0.9, 0.95, 0.99]\n  Recalls:    [0.6, 0.7, 0.8, 0.9, 0.95, 0.99]\n  Reconstruction (genomes):\n    P\\R   0.6  0.7  0.8  0.9 0.95 0.99\n    0.6     1    0    0    0    0    0\n    0.7     1    0    0    0    0    0\n    0.8     1    0    0    0    0    0\n    0.9     1    0    0    0    0    0\n    0.95    1    0    0    0    0    0\n    0.99    1    0    0    0    0    0","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"A wealth of information is readily available:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"binning.ref gives the underlying Reference\nbinning.recalls and binning.precisions gives the recall/precision thresholds used in benchmarking","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"The function print_matrix will display the number of recovered genomes/assemblies. It takes two optional keyword: level, the taxonomic rank (defaults to 0, meaning strain level), and assembly which defaults to true. If set to false, benchmark number of recovered genomes, not number of recovered assemblies.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> print_matrix(binning; level=1, assembly=false)\nP\\R   0.6  0.7  0.8  0.9 0.95 0.99\n0.6     1    0    0    0    0    0\n0.7     1    0    0    0    0    0\n0.8     1    0    0    0    0    0\n0.9     1    0    0    0    0    0\n0.95    1    0    0    0    0    0\n0.99    1    0    0    0    0    0","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"You can also get the number of genomes or assemblies reconstructed at a given precision/recall level directly with n_recovered:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> n_recovered(binning, 0.6, 0.7; assembly=true)\n1\n\njulia> n_recovered(binning, 0.66, 0.91; level=1)\n0","category":"page"},{"location":"walkthrough/#Bins","page":"Walkthrough","title":"Bins","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"The Binning object obviously contains our bins. Let's pick a random bin:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> bin = binning.bins[4]\nBin \"C4\"\n  Sequences: 3\n  Breadth:   55\n  Intersecting 2 genomes","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"The \"breadth\" here is the sum of the length of its sequences. bin.sequences gets an iterable of its sequences:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> collect(bin.sequences)\n3-element Vector{Sequence}:\n Sequence(\"s5\", 25)\n Sequence(\"s6\", 10)\n Sequence(\"s7\", 20)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"The \"Intersecting 2 genomes\" means that the sequences map to 2 different genomes - the only two in the reference. We can get that with the function intersecting, then get the precision/recall with recall_precision:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> Set(intersecting(bin)) == genomes(ref)\ntrue\n\njulia> recall_precision(genome2, bin)\n(recall = 0.6, precision = 1.0)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Or do the same for a higher clade - let's say a genus. In this case, we get the same result.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"julia> genus = only(Iterators.filter(i -> i.rank == 2, intersecting(Clade, bin)));\n\njulia> recall_precision(genus, bin)\n(recall = 0.6, precision = 1.0)","category":"page"},{"location":"cli_overview/#BinBencher.jl","page":"Overview","title":"BinBencher.jl","text":"","category":"section"},{"location":"cli_overview/","page":"Overview","title":"Overview","text":"BinBencher.jl is the command-line interface (CLI) around the BinBencherBackend, a program used to benchmark the output of a metagenomic binning, where the ground truth is known. The CLI program also includes functionality to create a reference JSON file.","category":"page"},{"location":"cli_overview/","page":"Overview","title":"Overview","text":"You can learn about the input files in the relevant section of the documentation.","category":"page"},{"location":"cli_overview/","page":"Overview","title":"Overview","text":"See more details about the subcommands of BinBencher.jl by navigating the documentation menu on the left.","category":"page"},{"location":"cli_overview/#Installation-of-the-CLI-program","page":"Overview","title":"Installation of the CLI program","text":"","category":"section"},{"location":"cli_overview/","page":"Overview","title":"Overview","text":"Install the Julia programming language\nLaunch the Julia REPL from a terminal by typing $ julia\nEnter Pkg mode in the REPL by typing ]. You will see the prompt change from julia> to e.g. (@v1.12) pkg> depending on the Julia version.\nCreate a new globally accessible project (i.e. virtual environment) by typing activate @binbencher in the pkg REPL.\nAdd BinBencher to the environment with add https://github.com/jakobnissen/BinBencher.jl\nIn the pkg repl, type build","category":"page"},{"location":"cli_overview/","page":"Overview","title":"Overview","text":"You will now have an executable script called binbench in the bin subdirectory your Julia home directory, e.g. on my computer it's at /home/jakni/.julia/bin/binbench. Add the bin folder to your PATH environmental variable to be able run to BinBencher as binbench from the shell.","category":"page"},{"location":"cli_overview/","page":"Overview","title":"Overview","text":"info: Info\nThese installation instruction are convoluted, because, as of September 2024, Julia does not have a concept of installable applications. There is recent work to improve this, so hopefully BinBencher will be easier to install and run by the time the work is done some time in 2025.","category":"page"},{"location":"cli_overview/#Quickstart","page":"Overview","title":"Quickstart","text":"","category":"section"},{"location":"cli_overview/","page":"Overview","title":"Overview","text":"$ # Make a reference JSON file\n$ binbench makeref ref_outdir --seq-mapping seq_mapping.tsv --seq-fasta contigs.fna \\\n--genome-directories organism=genomes --tax tax.tsv --tax-ncbi ncbi.tsv\n\n$ # Benchmark using the reference and a binning TSV file.\n$ binbench bench bench_outdir reference.json binning.tsv","category":"page"},{"location":"#BinBencher","page":"Home","title":"BinBencher","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BinBencher is a tool for analysis and benchmarking of a set of metagenomic assembled genomes (MAGs) against a reference. It is designed to be used for benchmarking metagenomic binners against a metagenome with a known ground truth, typically from a simulated metagenome such as the ones from CAMISIM, or alternatively from a laboratory-created mock community. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"BinBencher is pre-published at bioRxiv. Read that paper for background and motivation for this package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"BinBencher consists of two packages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"BinBencherBackend.jl: The Julia library that does the actual analysis.\nBinBencher.jl: An application that wraps the backend in a command-line interface (CLI).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Use the side bar to your left to find the documentation for either the library, for the CLI application. Most users probably want to use the CLI application.","category":"page"},{"location":"make_ref/#references","page":"Making a reference","title":"Creating a reference","text":"","category":"section"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"For more information on the reference, see the description of the JSON file format. For a definition of the concepts like source or genome, see the section on nomenclariture.","category":"page"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"At a high level, the reference contains:","category":"page"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"A list of the underlying genomes that are included in the simulation / the mock community.\nA tree that gives the phylogenetic relationship between these genomes\nA list of sequences included in the binning, and to which positions in the genomes they map to (are simulated from).","category":"page"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"In situations where the sequences have been simulated, you have perfect access to this information. However, there may be situations where this knowledge is only approximate - for example, if you simulate reads from the genomes and then assemble the reads, it might not be possible to know with 100% certainty where each contig ultimately is sourced from.","category":"page"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"Although you can manually create the reference JSON file, I recommend using the binbench makeref command. It takes a number of input files to extract all the information, which I will go through here:","category":"page"},{"location":"make_ref/#Genomes","page":"Making a reference","title":"Genomes","text":"","category":"section"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"Each genome must be stored in a single fasta file, and the genome takes its name from the FASTA file (stripping the file extension). The entries in this fasta file are the sources. These fasta files are stored in some directory. To set the flags of the genome, have one directory with fasta files per set of flags.","category":"page"},{"location":"make_ref/#Example","page":"Making a reference","title":"Example","text":"","category":"section"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"Given the following directory structure","category":"page"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":".\n├── collection_a\n│   ├── genome1.fna\n│   └── genome2.fna\n└── collection_b\n    └── genome3.fna","category":"page"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"And where the content of e.g. genome1.fna is:","category":"page"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":">seq1\nTAGA\n>seq2\nTAA\nGA","category":"page"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"You can pass --genome-directories plasmid+virus=collection_a,organism=collection_b. Thus, the genomes genome1 and genome2 will be have the flags virus and plasmid, and genome3 will have the flag organism. The genome genome1 will have two sources seq1 with length 4 and seq2 with length 5.","category":"page"},{"location":"make_ref/#seqs","page":"Making a reference","title":"Sequences","text":"","category":"section"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"The sequence (contig) names and lengths are obtained from reading a FASTA file with the sequences.","category":"page"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"The mapping position(s), if any, of each sequence is given by a 4-column TSV file with the sequence name, the source name, mapping start and mapping end (1-based, inclusive).","category":"page"},{"location":"make_ref/#Example-2","page":"Making a reference","title":"Example","text":"","category":"section"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"Given sequences seq1, seq2 and seq3, and the following mapping file","category":"page"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"sequence\tsource\tstart\tend\nseq1\tsrc1\t4\t9\nseq1\tsrc1\t11\t15\nseq1\tsrc2\t1\t6\nseq3\tsrc3\t15\t7","category":"page"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"seq1 maps to three locations, two of which are in the same source. Note that the length of the spans (mapping end to start) need not be the same\nseq2 is not present - it maps to nothing (or its mapping is unknown)\nseq3 maps exclusively to src3. Note that its mapping start is greater than its mapping end. This indicates that src3 is circular, and seq3 maps across the breakpoint (origin) of the sequence","category":"page"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"Mapping locations use 1-based indexing and are inclusive.","category":"page"},{"location":"make_ref/#Taxonomy","page":"Making a reference","title":"Taxonomy","text":"","category":"section"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"The taxonomy is specified with a 3-column TSV file with the header rank\\tchild\\tparent. The first column gives the rank, which may be one of: 'strain', 'species', 'genus', 'family', 'order', 'class', 'phylum', and gives the rank of the child. The second column gives the name of the child, which is either a genome name (if the rank is strain), or else a parent specified in this file. The last column gives the name of the parent.","category":"page"},{"location":"make_ref/#Example-3","page":"Making a reference","title":"Example","text":"","category":"section"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"rank\tchild\tparent\nstrain\tgenome1\tBacillus subtilis\nstrain\tgenome2\tBacillus subtilis\nstrain\tgenome3\tClostridium tetani\nspecies\tBacillus subtilis\tBacillus\nspecies\tClostridium tetani\tClostridium\ngenus\tBacillus\tBacillaceae\ngenus\tClostridium\tClostridiaceae\nfamily\tBacillaceae\tBacillales\nfamily\tClostridiaceae\tEubacteriales\norder\tBacillales\tBacilli\norder\tEubacteriales\tClostridia\nclass\tBacilli\t\tBacillota\nclass\tClostridia\tBacillota","category":"page"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"This specifies the full lineage of all three genomes up to a single universal ancestor of all the genomes (Bacillota, in this case).","category":"page"},{"location":"make_ref/#Using-NCBI-for-easier-taxonomy","page":"Making a reference","title":"Using NCBI for easier taxonomy","text":"","category":"section"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"It may be annoying to specify the full phylogenetic tree of all clades in the taxonomy file. To ease it, the parent may instead be listed as id=XXXX, where XXXX is an NCBI taxonomy ID on the parent rank. BinBencher will then fill up all higher ranks automatically. To enable this, --tax-ncbi must be passed on the command line to a file that contains a list of all known NCBI taxonomies. A link to this file can be found at the BinBencher github repo. So, the taxonomy file above can more easily be written as:","category":"page"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"rank\tchild\tparent\nstrain\tgenome1\tid=1423\nstrain\tgenome2\tid=1423\nstrain\tgenome3\tid=1513","category":"page"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"You do not need to specify the NCBI tax id for all entries, but can specify them for a subset of entries if necessary.","category":"page"},{"location":"make_ref/#Using-intermediate-JSON-files","page":"Making a reference","title":"Using intermediate JSON files","text":"","category":"section"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"The genomes, the sequences and the taxonomy are each parsed from their input files, and saved as intermediate JSON files.","category":"page"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"For example, after parsing in information about the sequences, BinBencher will create a seqs.json file. For subsequent runs, instead of passing the sequences fasta file and the mapping locations with --seq-fasta and --seq-mapping, you can pass the JSON file with --seq-json.","category":"page"},{"location":"make_ref/","page":"Making a reference","title":"Making a reference","text":"You can also manually create these intermediate output JSON files, such that you don't need to supply the corresponding input files. Suppose you want to create a reference, but that your genomes have such complex sets of flags that it is impractical to pass --genome-directories. You can then manually create the genomes intermediate JSON file and pass --genome-json instead of --genome-directories.","category":"page"}]
}
